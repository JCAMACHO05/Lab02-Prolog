%EJERCICIO 1
% --- HECHOS Y CAPACIDADES (PARÁMETROS DEL PROBLEMA) ---

% Coordenadas de las ubicaciones: ubicacion(ID, X, Y).
ubicacion(orilla_inicial, 0, 5).
ubicacion(piedra1, 2, 4).
ubicacion(piedra2, 5, 6).
ubicacion(piedra3, 8, 4).
ubicacion(piedra4, 5, 0).
ubicacion(orilla_final, 10, 5).

% Capacidad de la rana: distancia máxima de salto.
salto_maximo(4.0).

siguiente_estado(pos(LugarActual), pos(LugarSiguiente)) :-
    ubicacion(LugarActual, X1, Y1),
    ubicacion(LugarSiguiente, X2, Y2),
    LugarActual \= LugarSiguiente,
    salto_maximo(Max),
    Distancia is sqrt((X2-X1)^2+(Y2-Y1)^2),
    Distancia =< Max.
  
es_meta(pos(orilla_final)).

% Caso base
dfs(EstadoActual, Camino, Camino) :-
    es_meta(EstadoActual).

% Caso recursivo
dfs(EstadoActual, Visitados, Solucion) :-
    siguiente_estado(EstadoActual, EstadoSiguiente),
    \+ member(EstadoSiguiente, Visitados),
    dfs(EstadoSiguiente,
        [EstadoSiguiente | Visitados],
        Solucion).

buscar_solucion(Solucion) :-
    EstadoInicial = pos(orilla_inicial),
    dfs(EstadoInicial, [EstadoInicial], Solucion). 
% buscar_soluciones(S)




%EJERCICIO 2

power_list([
    power(logica, 100, 10),
    power(sigilo, 150, 30),
    power(fuerza, 250, 50)
]).

villain_list([
    villain(riddler, 90, [logica, sigilo]),
    villain(bane, 240, [fuerza])
]).

es_meta(estado([], _, _)).
siguiente_estado(
    estado(Villanos, Poderes, Energia),
    estado(NuevosVillanos, Poderes, NuevaEnergia)
) :-
    member(villain(Nombre, Vida, Debilidades), Villanos),
    member(power(Poder, Danio, Costo), Poderes),

    % Verificar debilidad
    member(Poder, Debilidades),

    % Verificar energia suficiente
    Energia >= Costo,

    NuevaEnergia is Energia - Costo,
    NuevaVida is Vida - Danio,

    actualizar_villanos(
        villain(Nombre, Vida, Debilidades),
        NuevaVida,
        Villanos,
        NuevosVillanos
    ).

actualizar_villanos(Villano, NuevaVida, Villanos, NuevosVillanos) :-
    select(Villano, Villanos, Resto),
    (
        NuevaVida =< 0
        -> NuevosVillanos = Resto
        ;  Villano = villain(N, _, D),
           NuevosVillanos = [villain(N, NuevaVida, D) | Resto]
    ).

dfs(Estado, _) :-
    es_meta(Estado).

dfs(EstadoActual, Visitados) :-
    siguiente_estado(EstadoActual, EstadoSiguiente),
    \+ member(EstadoSiguiente, Visitados),
    dfs(EstadoSiguiente,
        [EstadoSiguiente | Visitados]).

batman_can_win(EnergiaMaxima) :-
    power_list(Superpoderes),
    villain_list(Villanos),
    EstadoInicial = estado(Villanos, Superpoderes, EnergiaMaxima),
    dfs(EstadoInicial, [EstadoInicial]).

%batman_can_win(50)= False
%batman_can_win(60)= True

% EJERCICIO 3

es_meta(Estado) :-
    length(Estado, 8).

siguiente_estado(EstadoActual, NuevoEstado) :-
    length(EstadoActual, ColumnaActual),
    ColumnaSiguiente is ColumnaActual + 1,
    between(1, 8, Fila),
    es_segura(Fila, ColumnaSiguiente, EstadoActual),
    append(EstadoActual, [Fila], NuevoEstado).

es_segura(_, _, []).

es_segura(Fila, Columna, EstadoActual) :-
    verificar(Fila, Columna, EstadoActual, 1).

verificar(_, _, [], _).

verificar(Fila, Columna, [FilaExistente|Resto], ColumnaExistente) :-
    Fila =\= FilaExistente,
    abs(Fila - FilaExistente) =\= abs(Columna - ColumnaExistente),
    NuevaColumna is ColumnaExistente + 1,
    verificar(Fila, Columna, Resto, NuevaColumna).

% Caso base
dfs(EstadoActual, _, EstadoActual) :-
    es_meta(EstadoActual).

% Caso recursivo
dfs(EstadoActual, Visitados, SolucionFinal) :-
    siguiente_estado(EstadoActual, EstadoSiguiente),
    \+ member(EstadoSiguiente, Visitados),
    dfs(EstadoSiguiente,
        [EstadoSiguiente | Visitados],
        SolucionFinal).

solucion(Solucion) :-
    EstadoInicial = [],
    dfs(EstadoInicial, [EstadoInicial], Solucion).

% solucion(S) 
% S = [1, 5, 8, 6, 3, 7, 2, 4]
